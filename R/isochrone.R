#' Calculate isochrone using Dijkstra's algorithm
#'
#' @description This function calculates the isochrone for a set of starting nodes in a directed
#' graph using Dijkstra's algorithm. The isochrone is defined as the set of nodes that can be
#' reached from the starting nodes within a certain cost limit.
#' @param Graph A Graph object, generated by \code{\link[GeoRouteR]{makegraph}}.
#' @param from A vector of node IDs representing the starting node(s).
#' @param lim A numeric value or vector of values representing the maximum cost(s) of the isochrone.
#' @return a data frame with three columns: "from" (the starting node), "to"
#' (a node in the isochrone), and "cost" (the cost of the path from the starting node to the node)
#' @examples
#' \dontrun{
#' edges <- data.frame(from = c("A", "A", "B", "C"),
#'                     to = c("B", "C", "C", "D"),
#'                     speed = c(10, 20, 40, 100),
#'                     length = c(1, 2, 2, 1),
#'                     oneway = c("FT", "B", "N", "TF"))
#'
#' nodes <- data.frame(node = c("A", "B", "C", "D"),
#'                     X = c(0, 1, 1, 2),
#'                     Y = c(0, 0, 1, 1))
#'
#' crs <- "EPSG:4326"
#'
#' graph <- makegraph(edges, nodes, crs, directed = TRUE)
#'
#' # Calculate isochrones for a graph object
#' isochrones <- isochrone(graph, from = "A", lim = c(2, 6))
#' }
#' @export
#' @importFrom RcppParallel RcppParallelLibs
isochrone <- function(Graph, from, lim) {
  # Check input consistency
  checkmate::assert_class(Graph, "Graph")
  if (any(is.na(from))) stop("NAs are not allowed in origin nodes")
  
  from <- as.character(from)
  if (sum(from %in% Graph$node_dict()$node) < length(from)) stop("Some nodes are not in the graph")
  from_id <- Graph$node_dict()$id[match(from, Graph$node_dict()$node)]
  
  lim <- as.numeric(lim)
  if (any(is.na(lim))) stop("NAs are not allowed in cost value(s)")
  
  # Calculate isochrones using C++ function (Dijkstra)
  res <- calculate_isochrone(graph_ptr = Graph$pointer,
                             start_nodes_sexp = from_id,
                             lim_sexp = lim)
  
  # Order the result by 'start', 'cost', and 'end'
  res <- res[with(res, order(start, cost, end)), ]
  rownames(res) <- NULL
  
  # Add ref
  res$start <- Graph$node_dict()$node[match(res$start, Graph$node_dict()$id)]
  res$end <- Graph$node_dict()$node[match(res$end, Graph$node_dict()$id)]
  
  # Reorder and rename
  res <- data.frame(from = res$start,
                    to = res$end,
                    cost = res$cost,
                    threshold = res$threshold)
  
  return(res)
}