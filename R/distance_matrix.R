#' Calculate isochrone using Dijkstra's algorithm
#'
#' @description This function calculates the isochrone for a set of starting nodes in a directed
#' graph using Dijkstra's algorithm. The isochrone is defined as the set of nodes that can be
#' reached from the starting nodes within a certain cost limit.
#' @param Graph A Graph object, generated by \code{\link[GeoRouteR]{makegraph}}.
#' @param from A vector of node names representing the starting node(s).
#' @param to A vector of node names representing the starting node(s).
#' @param mode A character string; "time" or "distance".
#' @return a data frame with three columns: "from" (the starting node), "to"
#' (a node in the isochrone), and "cost" (the cost of the path from the starting node to the node)
#' @examples
#' \dontrun{
#' edges <- data.frame(from = c("A", "A", "B", "C"),
#'                     to = c("B", "C", "C", "D"),
#'                     speed = c(10, 20, 40, 100),
#'                     length = c(1, 2, 2, 1),
#'                     oneway = c("FT", "B", "N", "TF"))
#'
#' nodes <- data.frame(node = c("A", "B", "C", "D"),
#'                     X = c(0, 1, 1, 2),
#'                     Y = c(0, 0, 1, 1))
#'
#' crs <- "EPSG:4326"
#'
#' graph <- makegraph(edges, nodes, crs, directed = TRUE)
#'
#' # Calculate distance_matrix for a graph object
#' distance_matrix <- distance_matrix(graph, from = "A", to = "B")
#' }
#' @export
distance_matrix <- function(Graph, from, to, mode = "time") {
  # Check input consistency
  checkmate::assert_class(Graph, "Graph")
  if (any(is.na(from))) stop("NAs are not allowed in origin nodes")
  
  from <- as.character(from)
  if (sum(from %in% Graph$node_dict()$node) < length(from)) stop("Some nodes are not in the graph")
  from_id <- Graph$node_dict()$id[match(from, Graph$node_dict()$node)]
  
  to <- as.character(to)
  if (sum(to %in% Graph$node_dict()$node) < length(to)) stop("Some nodes are not in the graph")
  to_id <- Graph$node_dict()$id[match(to, Graph$node_dict()$node)]
  
  checkmate::assert_choice(mode, c("time", "distance"))
  
  # Calculate isochrones using C++ function (Dijkstra)
  res <- calculate_dist_mat(graph_ptr = Graph$pointer,
                            start_nodes_sexp = from_id,
                            end_nodes_sexp = to_id,
                            mode_sexp = mode)
  res <- res[res$start != res$end,]
  rownames(res) <- NULL
  
  # Add ref
  res$start <- Graph$node_dict()$node[match(res$start, Graph$node_dict()$id)]
  res$end <- Graph$node_dict()$node[match(res$end, Graph$node_dict()$id)]
  
  # Rename
  names(res) <- c("from", "to", "cost")
  
  return(res)
}